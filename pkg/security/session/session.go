package session

import (
	"net/http"
	"time"
)

// Default flashes key.
const flashesKey = "_flash"
const createdTimeKey = "_created"

type Session struct {
	//Used to indicate if the session Values has been modified - and should be saved
	dirty bool

	//Updated every time the session is accessed. Used to calculate timeout
	lastAccessed time.Time

	// The ID of the session, generated by stores. It should not be used for
	// user data.
	ID string
	// Values contains the user-data for the session.
	// Because the value is declared as interface, any concrete type that is stored in the Values map need to register with gob
	// if used with a store that serializes using gob. See NewRedisStore
	Values  map[interface{}]interface{}
	Options *Options
	IsNew   bool
	store   Store
	name    string
}

type Options struct {
	Path   string
	Domain string

	// Determines how the cookie's "Max-Age" attribute will be set
	// MaxAge=0 means no 'Max-Age' attribute specified.
	// MaxAge<0 means delete cookie now, equivalently 'Max-Age: 0'
	// MaxAge>0 means Max-Age attribute present and given in seconds
	MaxAge   int
	Secure   bool
	HttpOnly bool
	// Defaults to http.SameSiteDefaultMode
	SameSite http.SameSite

	IdleTimeout time.Duration
	AbsoluteTimeout time.Duration
}

func NewSession(store Store, name string) *Session {
	opts := *store.Options() // a copy of the store's option

	return &Session{
		Values:  make(map[interface{}]interface{}),
		store:   store,
		name:    name,
		Options: &opts,
		IsNew: true,
		dirty: false,
	}
}

// NewCookie returns an http.Cookie with the options set. It also sets
// the Expires field calculated based on the MaxAge value, for Internet
// Explorer compatibility.
func NewCookie(name, value string, options *Options) *http.Cookie {
	cookie := newCookieFromOptions(name, value, options)
	if options.MaxAge > 0 {
		d := time.Duration(options.MaxAge) * time.Second
		cookie.Expires = time.Now().Add(d)
	} else if options.MaxAge < 0 {
		// Set it to the past to expire now.
		cookie.Expires = time.Unix(1, 0)
	}
	return cookie
}

// newCookieFromOptions returns an http.Cookie with the options set.
func newCookieFromOptions(name, value string, options *Options) *http.Cookie {
	return &http.Cookie{
		Name:     name,
		Value:    value,
		Path:     options.Path,
		Domain:   options.Domain,
		MaxAge:   options.MaxAge,
		Secure:   options.Secure,
		HttpOnly: options.HttpOnly,
		SameSite: options.SameSite,
	}

}

// ID returns the name used to register the session.
func (s *Session) GetID() string {
	return s.ID
}

// Name returns the name used to register the session.
func (s *Session) Name() string {
	return s.name
}

// Get returns the session value associated to the given key.
func (s *Session) Get(key interface{}) interface{} {
	return s.Values[key]
}

// Set sets the session value associated to the given key.
func (s *Session) Set(key interface{}, val interface{}) {
	s.Values[key] = val
	s.SetDirty()
}

// Delete removes the session value associated to the given key.
func (s *Session) Delete(key interface{}) {
	if _, ok := s.Values[key]; ok {
		delete(s.Values, key)
		s.SetDirty()
	}
}

// Clear deletes all values in the session.
func (s *Session) Clear() {
	s.Values = make(map[interface{}]interface{})
	s.SetDirty()
}

// Flashes returns a slice of flash messages from the session.
//
// A single variadic argument is accepted, and it is optional: it defines
// the flash key. If not defined "_flash" is used by default.
func (s *Session) Flashes(flashKey ...string) []interface{} {
	defer s.SetDirty()

	var flashes []interface{}
	key := flashesKey
	if len(flashKey) > 0 {
		key = flashKey[0]
	}
	if v, ok := s.Values[key]; ok {
		// Drop the flashes and return it.
		delete(s.Values, key)
		flashes = v.([]interface{})
	}
	return flashes
}

// AddFlash adds a flash message to the session.
//
// A single variadic argument is accepted, and it is optional: it defines
// the flash key. If not defined "_flash" is used by default.
func (s *Session) AddFlash(value interface{}, flashKey ...string) {
	key := flashesKey
	if len(flashKey) > 0 {
		key = flashKey[0]
	}
	var flashes []interface{}
	if v, ok := s.Values[key]; ok {
		flashes = v.([]interface{})
	}
	s.Values[key] = append(flashes, value)
	s.SetDirty()
}

// Save is a convenience method to save this session. It is the same as calling
// store.Save(request, response, session).
func (s *Session) Save() (err error) {
	if !s.dirty {
		return
	}

	err = s.store.Save(s)
	return
}

func (s *Session) IsDirty() bool {
	return s.dirty
}

func (s *Session) SetDirty()  {
	s.dirty = true
}

func (s *Session) isExpired() bool {
	now := time.Now()
	exp := s.expiration()

	return exp.Before(now)
}

func (s *Session) createdOn() time.Time {
	if t, ok := s.Values[createdTimeKey]; ok {
		return t.(time.Time)
	} else {
		return time.Time{}
	}
}

func (s *Session) expiration() time.Time {
	idleExpiration := s.lastAccessed.Add(s.Options.IdleTimeout)
	absExpiration := s.createdOn().Add(s.Options.AbsoluteTimeout)

	//whichever is the earliest
	if idleExpiration.Before(absExpiration) {
		return idleExpiration
	} else {
		return absExpiration
	}
}