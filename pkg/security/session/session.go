package session

import (
	"net/http"
	"time"
)

// Default flashes key.
const flashesKey = "_flash"

type Attributes map[interface{}]interface{}

type Session struct {
	//Used to indicate if the session Values has been modified - and should be saved
	dirty bool

	//Updated every time the session is accessed. Used to calculate timeout
	lastAccessed time.Time

	// The ID of the session, generated by stores. It should not be used for
	// user data.
	ID string
	// Values contains the user-data for the session.
	Values  Attributes
	Options *Options
	IsNew   bool
	store   Store
	name    string
}

type Options struct {
	Path   string
	Domain string
	// MaxAge=0 means no Max-Age attribute specified and the cookie will be
	// deleted after the browser session ends.
	// MaxAge<0 means delete cookie immediately.
	// MaxAge>0 means Max-Age attribute present and given in seconds.
	MaxAge   int
	Secure   bool
	HttpOnly bool
	// Defaults to http.SameSiteDefaultMode
	SameSite http.SameSite
}

func NewSession(store Store, name string) *Session {
	opts := *store.Options() // a copy of the store's option
	return &Session{
		Values:  make(Attributes),
		store:   store,
		name:    name,
		Options: &opts,
		IsNew: true,
		dirty: false,
		lastAccessed: time.Now(),
	}
}

// NewCookie returns an http.Cookie with the options set. It also sets
// the Expires field calculated based on the MaxAge value, for Internet
// Explorer compatibility.
func NewCookie(name, value string, options *Options) *http.Cookie {
	cookie := newCookieFromOptions(name, value, options)
	if options.MaxAge > 0 {
		d := time.Duration(options.MaxAge) * time.Second
		cookie.Expires = time.Now().Add(d)
	} else if options.MaxAge < 0 {
		// Set it to the past to expire now.
		cookie.Expires = time.Unix(1, 0)
	}
	return cookie
}

// newCookieFromOptions returns an http.Cookie with the options set.
func newCookieFromOptions(name, value string, options *Options) *http.Cookie {
	return &http.Cookie{
		Name:     name,
		Value:    value,
		Path:     options.Path,
		Domain:   options.Domain,
		MaxAge:   options.MaxAge,
		Secure:   options.Secure,
		HttpOnly: options.HttpOnly,
		SameSite: options.SameSite,
	}

}

//TODO: declare these methods as interface

// ID returns the name used to register the session.
func (s *Session) GetID() string {
	return s.ID
}

// Name returns the name used to register the session.
func (s *Session) Name() string {
	return s.name
}

// Get returns the session value associated to the given key.
func (s *Session) Get(key interface{}) interface{} {
	return s.Values[key]
}

// Set sets the session value associated to the given key.
func (s *Session) Set(key interface{}, val interface{}) {
	s.Values[key] = val
	s.SetDirty()
}

// Delete removes the session value associated to the given key.
func (s *Session) Delete(key interface{}) {
	if _, ok := s.Values[key]; ok {
		delete(s.Values, key)
		s.SetDirty()
	}
}

// Clear deletes all values in the session.
func (s *Session) Clear() {
	s.Values = make(map[interface{}]interface{})
	s.SetDirty()
}

// Flashes returns a slice of flash messages from the session.
//
// A single variadic argument is accepted, and it is optional: it defines
// the flash key. If not defined "_flash" is used by default.
func (s *Session) Flashes(flashKey ...string) []interface{} {
	defer s.SetDirty()

	var flashes []interface{}
	key := flashesKey
	if len(flashKey) > 0 {
		key = flashKey[0]
	}
	if v, ok := s.Values[key]; ok {
		// Drop the flashes and return it.
		delete(s.Values, key)
		flashes = v.([]interface{})
	}
	return flashes
}

// AddFlash adds a flash message to the session.
//
// A single variadic argument is accepted, and it is optional: it defines
// the flash key. If not defined "_flash" is used by default.
func (s *Session) AddFlash(value interface{}, flashKey ...string) {
	key := flashesKey
	if len(flashKey) > 0 {
		key = flashKey[0]
	}
	var flashes []interface{}
	if v, ok := s.Values[key]; ok {
		flashes = v.([]interface{})
	}
	s.Values[key] = append(flashes, value)
	s.SetDirty()
}

// Options sets configuration for a session.
func (s *Session) WithOptions(options *Options) {
	s.Options = options
}

// Save is a convenience method to save this session. It is the same as calling
// store.Save(request, response, session).
func (s *Session) Save() (err error) {
	if !s.dirty {
		return
	}

	err = s.store.Save(s)
	return
}

func (s *Session) IsDirty() bool {
	return s.dirty
}

func (s *Session) SetDirty()  {
	s.dirty = true
}