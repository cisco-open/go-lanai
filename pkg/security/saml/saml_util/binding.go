package saml_util

import (
	"github.com/crewjam/saml"
	"net/http"
	"net/url"
)



// ResolveBinding find first supported binding using given binding location extractor
func ResolveBinding(supported []string, extractor func(string) string) (location, binding string) {
	for _, b := range supported {
		location = extractor(b)
		if location != "" {
			binding = b
			return
		}
	}
	return "", ""
}

// BindableSamlRequest abstracted interface that both saml.AuthnRequest and FixedLogoutRequest implements
type BindableSamlRequest interface {
	Redirect(relayState string, sp *saml.ServiceProvider) (*url.URL, error)
	Post(relayState string) []byte
}

func RedirectBindingExecutor(req BindableSamlRequest, relayState string, sp *saml.ServiceProvider) func(w http.ResponseWriter, r *http.Request) error {
	return func(w http.ResponseWriter, r *http.Request) error {
		redirectURL, e := req.Redirect(relayState, sp)
		if e != nil {
			return e
		}
		http.Redirect(w, r, redirectURL.String(), http.StatusFound)
		_, _ = w.Write(nil)
		return nil
	}
}

func PostBindingExecutor(req BindableSamlRequest, relayState string) func(w http.ResponseWriter, r *http.Request) error {
	return func(w http.ResponseWriter, r *http.Request) error {
		//add a hash for the inline script generated by authReq.Post so that we know only
		//this inline script is executed.
		//this is to prevent the case of the html is injected by bad actors, although it's unlikely in our case
		w.Header().Add("Content-Security-Policy", ""+
			"default-src; "+
			"script-src 'sha256-AjPdJSbZmeWHnEc5ykvJFay8FTWeTeRbs9dutfZ0HqE='; "+ //this hash matches the inline script generated by authReq.Post
			"reflected-xss block; referrer no-referrer;")
		w.Header().Add("Content-Type", "text/html")

		body := append([]byte(`<!DOCTYPE html><html><body>`), req.Post(relayState)...)
		body = append(body, []byte(`</body></html>`)...)
		_, e := w.Write(body)
		return e
	}
}

