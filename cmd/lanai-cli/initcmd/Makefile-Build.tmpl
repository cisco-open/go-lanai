.SECONDEXPANSION:

DOCKER = docker
SSHADD = ssh-add

DESTDIR = dist
MODULE = {{ .Module.Path }}

EXECS = {{- range $key, $_ := .Executables }} {{ $key }} {{- end }}

GEN_LIST = \
	{{- range .Generates }}
	generate@{{ .Path }} \
	{{- end }}

RES_LIST = \
	{{- range .Resources }}
	resource@{{ .Output }} \
	{{- end }}

# target patterns
pGenerate = generate@%
pResource = resource@%

# Main
.PHONY: generate clean test build copy-resources $(GEN_LIST) $(EXECS) $(RES_LIST)

generate: init $(GEN_LIST)

test: generate
	$(GO) test -count=1 -v -failfast -timeout 0 -coverprofile $(DESTDIR)/coverage.out $(MODULE)/pkg/...

build: $(EXECS) copy-resources

copy-resources: $(RES_LIST)

# Docker
init-docker: init-once
	# ssh-add is necessary for build-docker
	$(SSHADD) -K ~/.ssh/id_rsa

build-docker: init-docker generate
	$(DOCKER) build -f "build/package/Dockerfile" --ssh default --progress=plain . -t europa:latest

clean:
	rm -rf $(DESTDIR)/*

# Generate
$(GEN_LIST):
	$(GO) generate $(@:$(pGenerate)=%)

# Build
	{{- range $name, $elem := .Executables }}
{{ $name }}:
	$(GO) build -o $(DESTDIR)/$@ {{ $elem.Main }}
	{{ end }}

# Copy Resources
	{{- range .Resources }}
resource@{{ .Output }}:
	cp -rf {{ .Pattern }} $(DESTDIR)/{{ .Output }}
	{{ end }}


#The following example is useful for CI CD scenarios such as nightly build, PR review and stable release.
#For example:
# 1. Nightly build can use pre-build and post-build-tag-only with the actual build in the middle.
#    This will result in a tag off of the main branch.
# 2. Promoting of certain build from a tag or branch can use pre-build and post-build with the actual build in the middle.
# 	 This will result in a tag off of the main branch. The updated go.mod will also be merged back into the main branch.
# 3. PR verification can use pre-verify. This will not create any tag or commits.
# For more details, see the build.md file in the docs directory.

#useful for PR review - get mod file ready but no commit
#need to provide module to be updated
# e.g. make pre-verify module=cto-github.cisco.com/NFV-BU/go-lanai:develop
pre-verify: update-dependency drop-replace tidy

#useful for any build - creates two commits. the first commit can be used to merge back to main branch. the second commit can be used for tagging
#need to provide temporary branch name, and module to be updated
# e.g. make pre-build module=cto-github.cisco.com/NFV-BU/go-lanai:develop branch-name=tmp
pre-build: git-branch update-dependency git-commit-dep-update drop-replace tidy git-commit-drop-replace

#useful for nightly build - tag the build, but do not merge back to main branch
#need to provide tag value, and the original branch. The original branch value is needed to clean up the temporary branch created.
#(switch to original branch and delete the temporary branch)
# e.g. make post-build-tag-only tag-version=0.0.1 original-branch=develop remove-branch=tmp
post-build-tag-only: git-tag git-publish-tag git-clean-up

#useful for release build - tag the build, and also merge back to main branch with the updated dependencies
#publish tag after merge so both push and push tags is at the very end.
#need to provide tag value, and original branch to merge back to
# e.g. make post-build tag-version=0.0.1 original-branch=develop remove-branch=tmp
post-build: git-tag git-pop-commit-from-back git-merge-back git-publish-tag git-clean-up


#Used to update the module dependency versions
#Will update go.mod's dependency to given branch's latest commit
#This target requires a command line input to specify from which branch to update the dependency
# The dependency version can either be a branch - useful for PR verification
# Or it can be a version query - useful for builds that are tagged (nightly or release)
# e.g make update-dependency module=cto-github.cisco.com/NFV-BU/go-lanai:develop
update-dependency:
	$(CLI) update-dep --dep-branch=$(module)

# e.g. make drop-replace module=cto-github.cisco.com/NFV-BU/go-lanai:develop
# or make drop-replace module=cto-github.cisco.com/NFV-BU/go-lanai
drop-replace:
	$(CLI) drop-replace --module=$(module)

#use this after dependency is updated and replace directive is dropped.
#Because if there is a replace directive but the module that's replaced is not being used,
#go mod tidy will remove the dependency but not the replace directive. That would leave the go.mod in an error state
tidy:
	$(GO) mod tidy

git-branch:
	$(GIT) checkout -b $(branch-name)

git-commit-dep-update:
	[ -f go.mod ] && $(GIT) add go.mod;
	[ -f go.sum ] && $(GIT) add go.sum;
	$(GIT) commit --allow-empty -m "build process updated dependency. empty commit means go.mod and go.sum was up to date."

git-commit-drop-replace:
	[ -f go.mod ] && $(GIT) add go.mod;
	[ -f go.sum ] && $(GIT) add go.sum;
	$(GIT) commit --allow-empty -m "build process removed replace directive. empty commit means no replace directive was found"

git-tag:
	$(GIT) tag -a $(tag-version) -m "build tag"

git-publish-tag:
	$(GIT) push --tags

git-pop-commit-from-back:
	$(GIT) reset --hard HEAD^

git-clean-up:
	$(GIT) checkout $(original-branch)
	$(GIT) branch -D $(remove-branch)

git-merge-back:
	set -e ;\
	br=$$($(GIT) branch --show-current) ;\
	$(GIT) checkout $(original-branch) ;\
	$(GIT) pull ;\
	$(GIT) merge $$br ;\
	$(GIT) push

# may be useful to check if current branch is the expected branch
git-verify-current-branch:
	set -e ;\
	br=$$($(GIT) branch --show-current) ;\
	[ $$br = $(current-branch) ] || exit 1