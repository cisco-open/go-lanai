### Generated by lanai-cli. DO NOT MODIFY.
### Any modification to Makefile-Generated will be discarded during build

### Global Variables
.SECONDEXPANSION:

### Main
.PHONY: init-docker pre-build-docker build-docker push-docker \
	pre post dist report verify publish redist pre-verify post-verify pre-dist post-dist \
	update-dependency drop-replace git-tag-version git-push-tag git-merge-back git-verify-current-branch

## Variables from make command-line
# PRIVATE_MODS:	private modules and its version/branch/tag to use. comma delimited if multiple modules
# 				e.g. PRIVATE_MODS=github.com/<org>/<my-private-dependency>@v0.1.0,github.my-domain.com/<org>/<repo>@0.2.1
PRIVATE_MODS ?= {{.CliModPath}}@develop
# VERSION:	application version to be distributed/build (without leading "v").
# 			e.g. VERSION=4.0.0-50
VERSION ?= 0.0.0-SNAPSHOT
# SRC_BRANCH:	(Optional) source branch this distribution originated from.
#				This value is required only if CI/CD want to merge go.mod and go.sum back to source branch
SRC_BRANCH ?=

## Derived Variables

## Required Variables by Local Targets
DOCKER ?= docker
SSHADD ?= ssh-add
GO ?= go
GIT ?= git
CLI ?= lanai-cli


## CI/CD
## Predefined common CI/CD tasks. Such as PR verification, nightly build/release, etc

# report:
# 	Test and generate report. Intended to be used by verification.
report: test
	$(GO) tool cover -html=$(DESTDIR)/coverage.out -o $(DESTDIR)/coverage.html
	gotestsum --junitfile="$(DESTDIR)/junit-report.xml" --raw-command -- cat $(DESTDIR)/tests.json 2>&1 1>/dev/null
	gocov convert $(DESTDIR)/coverage.out | gocov-xml > $(DESTDIR)/cobertura-coverage.xml

# verify:
#	Test and build application against specified PRIVATE_MODS.
# 	Required Vars:
#		- PRIVATE_MODS
#	Example:
# 		make verify PRIVATE_MODS=github.com/<org>/<my-private-dependency>@develop
verify: SAVEPOINT_MARK = tmp/pre-verify
verify: pre-verify clean test lint build report post-verify

# dist:
#	Make a distribution build with provided PRIVATE_MODS and VERSION,
#	tag the source code that could be used to re-build the distribution,
#	and optionally merge updated go.mod/go.sum back to SRC_BRANCH if provided
# 	Required Vars:
#		- PRIVATE_MODS
# 		- VERSION
# 	Optional Vars:
#		- SRC_BRANCH source branch this distribution originated from.
# 		  If set, post-dist would behave differently
#	Example:
# 		make dist PRIVATE_MODS=github.com/<org>/<my-private-dependency>@develop VERSION=4.0.0-20 SRC_BRANCH=develop
dist: UPDATE_DEPS_MARK = tmp/$(VERSION)/update-deps
dist: DROP_REPLACE_MARK = tmp/$(VERSION)/drop-replace
dist: SAVEPOINT_MARK = tmp/pre-dist
dist: pre-dist clean test pre-build-docker build-docker post-dist

# publish:
#	Publish a distribution build. Push Docker image, push Git release tag, etc
# 	Required Vars:
# 		- VERSION
#	Example:
#		(after make dist PRIVATE_MODS=github.com/<org>/<my-private-dependency>@develop VERSION=4.0.0-20 SRC_BRANCH=develop)
# 		make publish VERSION=4.0.0-20
publish: push-docker git-push-tag

# redist:
#	Make redistribution build from previously released Git Tag (aka, promote)
#	re-build current Git worktree with updated $(VERSION) as-is.
# 	Note: this should be performed on a released git tag. No modification of go.mod or test is performed
# 	Required Vars:
# 		- VERSION
#	Example:
# 		make redist VERSION=4.0.0-20
redist: GIT_SRC_TAG =
redist: SAVEPOINT_MARK = tmp/pre-redist
redist: pre clean build-docker git-tag-version post

## Docker
## Prerequisites for building docker image:
## 		- Working machine should have access to relative private Git repositories. (setup by "init-once")
##		- Working machine's ~/.ssh/id_rsa should be added via "ssh-add" for private GitHub servers
##		- Minimum Docker version on working machine is 18.09

# init-docker:
# 	Initialize for building docker image. Typically run on CI/CD worker machine
init-docker:
	# ssh-add is necessary for build-docker, loads default keys.
	# for CI/CD it's managed by jenkins
	$(SSHADD) -K || true 

# pre-build-docker:
# 	Before build docker image, set current head commit to proper marked commit
pre-build-docker:
	$(CLI) git mark revert -t $(DROP_REPLACE_MARK)

# build-docker:
# 	Build docker image. Typically run on CI/CD worker machine
#       Required Vars: for non-buildkit build
#               - GITKEY ssh key for any private git repositories
# 	Optional Vars:
#		- PRIVATE_MODS used for populating build info
#		- VERSION application version also used as Docker's image tag. Default to "latest" if not specified
build-docker: DOCKER_TAG = $(if $(VERSION),$(VERSION),latest)
build-docker: BASE_IMAGE_ARG = $(if $(BASE_IMAGE),--build-arg BASE_IMAGE="$(BASE_IMAGE)",)
build-docker: init-docker
	$(DOCKER) build -f "build/package/Dockerfile" \
	--ssh default \
	--progress=plain \
	--label service_version=$(DOCKER_TAG) \
	-t {{.Name}}:$(DOCKER_TAG) . \
	--build-arg PRIVATE_MODS="$(PRIVATE_MODS)" \
	--build-arg VERSION="$(VERSION)" \
	--build-arg GITKEY="$(GITKEY)" \
	$(BASE_IMAGE_ARG)

# push-docker:
#	Re-tag and push given docker image to remote
# 	Required Vars:
#		- DOCKER_TAG: default to $(VERSION)
#		- DOCKER_REPO: Docker repository path/url without tailing "/"
push-docker: DOCKER_TAG ?= $(VERSION)
push-docker: DOCKER_REPO ?= dockerhub.cisco.com/vms-platform-dev-docker
push-docker:
	$(DOCKER) tag {{.Name}}:$(DOCKER_TAG) $(DOCKER_REPO)/{{.Name}}:$(DOCKER_TAG)
	$(DOCKER) push $(DOCKER_REPO)/{{.Name}}:$(DOCKER_TAG)

## CI/CD AdHoc Targets
## The following targets are useful for CI/CD scenarios such as nightly build, PR review and stable release.
## For example:
## 1.	Nightly build: use pre-dist and post-dist without specifying SRC_BRANCH.
## 		This will result in a tag off of the current branch.
## 2.	Promoting of certain build from a tag or branch: use pre-dist and post-dist without specifying SRC_BRANCH.
## 		This will result in a tag off of the current branch.
## 3.	Making end-of-cycle release: use pre-dist and post-dist with a SRC_BRANCH.
## 		This will result in a tag off of the current branch. The updated go.mod will also be merged back into the source branch.
## 4.	PR verification: use pre-verify. This will not create any tag or commits.
## 		For more details, see the build.md file in the docs directory.

pre:
	$(GIT) tag -l tmp/* | xargs git tag -d
	$(CLI) git mark create -t $(SAVEPOINT_MARK)

post:
	$(CLI) git mark revert -t $(SAVEPOINT_MARK)

# pre-verify:
#	useful for PR review - get mod file ready but no commit.
# 	Required Vars:
#		- PRIVATE_MODS
pre-verify: SAVEPOINT_MARK ?= tmp/pre-verify
pre-verify: pre update-dependency drop-replace

# post-verify:
#	useful for PR review - revert to initial state
post-verify: SAVEPOINT_MARK ?= tmp/pre-verify
post-verify: post


# pre-dist:
#	useful for any distribution build - get mod file ready
# 	Prepare workspace for distribution build against released dependencies:
# 	 1. create a local git tag to record initial state of worktree
# 	 2. update go.mod for dependencies listed in PRIVATE_MODS, and create a local git commit to record the result.
#		the commit is tagged as $(UPDATE_DEPS_MARK), and can be used to merge back to main branch
#	 3. update go.mod to drop "replace" directives for modules listed in PRIVATE_MODS, and create a local git commit to record the result.
# 		the commit is tagged as $(DROP_REPLACE_MARK), and can be used for make release git tag
# 	Required Vars:
#		- PRIVATE_MODS e.g. make pre-dist PRIVATE_MODS=github.com/<org>/<my-private-dependency>@develop
#		- VERSION
pre-dist: UPDATE_DEPS_MARK ?= tmp/$(VERSION)/update-deps
pre-dist: DROP_REPLACE_MARK ?= tmp/$(VERSION)/drop-replace
pre-dist: SAVEPOINT_MARK ?= tmp/pre-dist
pre-dist: pre update-dependency drop-replace

# post-dist:
# 	useful for any distribution build - finalize the build and revert to initial state
# 	Required Vars:
#		- VERSION
#need to provide tag value, and original branch to merge back to
# e.g. make post-build tag-version=0.0.1 original-branch=develop remove-branch=tmp
post-dist: UPDATE_DEPS_MARK ?= tmp/$(VERSION)/update-deps
post-dist: DROP_REPLACE_MARK ?= tmp/$(VERSION)/drop-replace
post-dist: SAVEPOINT_MARK ?= tmp/pre-dist
post-dist: post git-tag-version git-merge-back

# update-dependency:
# 	Used to update the module dependency versions - update go.mod's dependency to given branch's latest commit
#	This target requires a command line input to specify from which branch to update the dependency
# 	The dependency version can either be a branch - useful for PR verification
# 	or it can be a version query - useful for builds that are tagged (nightly or release)
# 	Required Vars:
#		- PRIVATE_MODS
# 	Optional Vars:
#		- UPDATE_DEPS_MARK: when set, the target will create a git commit for result go.mod/go.sum file and tag it as UPDATE_DEPS_MARK
# 		  Note: the create commit is not tracked by current branch HEAD
#	Example:
# 		make update-dependency PRIVATE_MODS=github.com/<org>/<my-private-dependency>@develop
update-dependency:
	$(CLI) deps update --modules=$(PRIVATE_MODS) --mark=$(UPDATE_DEPS_MARK)

# drop-replace:
# 	Used to prepare go.mod/go.sum for relasing - drop replace specified by PRIVATE_MODS
#	use this after dependency is updated, because if there is a replace directive but the module that's replaced is not being used,
#	go mod tidy will remove the dependency but not the replace directive. That would leave the go.mod in an error state
# 	Required Vars:
#		- PRIVATE_MODS
# 	Optional Vars:
#		- DROP_REPLACE_MARK: when set, the target will create a git commit for result go.mod/go.sum file and tag it as UPDATE_DEPS_MARK
# 		  Note: the create commit is not tracked by current branch HEAD
#	Example:
# 		make drop-replace PRIVATE_MODS=github.com/<org>/<my-private-dependency>@develop
drop-replace:
	$(CLI) deps drop-replace --modules=$(PRIVATE_MODS) --mark=$(DROP_REPLACE_MARK)

# git-tag-version:
#	Create a release Git Tag from given Git Tag, which is useful when "dist" or "promote"
# 	Required Vars:
#		- GIT_TAG: Tag to be created, default to v$(VERSION)
# 		- GIT_SRC_TAG: Source Tag, default to $(DROP_REPLACE_MARK)
git-tag-version: GIT_SRC_TAG ?= $(DROP_REPLACE_MARK)
git-tag-version: GIT_TAG ?= v$(VERSION)
git-tag-version:
	$(CLI) git mark retag -t $(GIT_TAG) $(if $(GIT_SRC_TAG),--src-tag $(GIT_SRC_TAG))

# git-push-tag:
#	Push given to remote
# 	Required Vars:
#		- GIT_TAG: Tag to push, default to v$(VERSION)
git-push-tag: GIT_TAG ?= v$(VERSION)
git-push-tag:
	$(GIT) push origin $(GIT_TAG)

# git-merge-back:
#	Merge commit marked by given Git Tag (GIT_SRC_TAG) back to SRC_BRANCH.
#	Useful on particular scenario when changes during build/dist/release process is necessary to be merged by to dev source
# 	Required Vars:
#		- SRC_BRANCH
# 		- GIT_TAG: Tag to be merged back, default to $(UPDATE_DEPS_MARK)
git-merge-back: GIT_TAG ?= $(UPDATE_DEPS_MARK)
git-merge-back:
ifneq ($(SRC_BRANCH),)
	@echo "$(GIT) push . $(GIT_TAG):origin/$(SRC_BRANCH)"
	@$(GIT) push . $(GIT_TAG):origin/$(SRC_BRANCH) || \
	echo "ERROR: Unable to merge $(GIT_TAG) to $(SRC_BRANCH). Manual operations are required"
endif

# may be useful to check if current branch is the expected branch
git-verify-current-branch:
	set -e ;\
	br=$$($(GIT) branch --show-current) ;\
	[ $$br = $(current-branch) ] || exit 1
