### Generated by lanai-cli. DO NOT MODIFY.
### Any modification to Makefile-Generated will be discarded during build

### Global Variables
.SECONDEXPANSION:

### Main
.PHONY: generate clean test build copy-resources init-docker build-docker \
	pre post dist verify pre-verify post-verify pre-dist post-dist \
	update-dependency drop-replace git-publish-tag git-merge-back git-verify-current-branch

## Required Variables from make command-line
# PRIVATE_MODS:	private modules and its version/branch/tag to use. comma delimited if multiple modules
# 				e.g. PRIVATE_MODS=cto-github.cisco.com/NFV-BU/go-lanai@v0.1.0,cto-github.cisco.com/NFV-BU/swagger-go@0.2.1
PRIVATE_MODS ?= {{.CliModPath}}@develop
# VERSION:	application version to be distributed/build (without leading "v").
# 			e.g. VERSION=4.0.0-50
VERSION ?= v0.0.0-SNAPSHOT
# SRC_BRANCH:	(Optional) source branch this distribution originated from.
#				This value is required only if CI/CD want to merge go.mod and go.sum back to source branch
SRC_BRANCH ?=

## Required Variables by Local Targets
CLI_PKG_PATH ?= $(filter {{.CliModPath}}%,$(PRIVATE_MODS))
CLI_TAG ?= $(patsubst {{.CliModPath}}%,%,$(CLI_PKG_PATH))

DOCKER ?= docker
SSHADD ?= ssh-add
GO ?= go
GIT ?= git
CLI ?= lanai-cli

DESTDIR ?= dist
MODULE ?= {{ .Module.Path }}

EXECS ?= {{- range $key, $_ := .Executables }} {{ $key }} {{- end }}
GEN_LIST ?= {{- range .Generates }} generate@{{ .Path }} {{- end }}
RES_LIST ?= {{- range .Resources }} resource@{{ .Output }} {{- end }}



## Build AdHoc Targets
# generate:
# 	Invoke "go generate" on defined targets
# 	This target typically run on CI/CD working machine
generate: $(GEN_LIST)

# test:
# 	Invoke "go test" on defined modules.
# 	This target typically run on CI/CD working machine
test: generate
	$(GO) test -count=1 -v -failfast -timeout 0 -coverprofile $(DESTDIR)/coverage.out $(MODULE)/pkg/...

# build:
# 	Generate executable binary and copy resources to $(DESTDIR)
# 	this target should be run on targeted OS.
#	e.g. build is executed inside Docker container when building Docker image
build: $(EXECS) copy-resources

# copy-resources:
#	Copy resources to $(DESTDIR) based on $(RES_LIST)
# 	This target should be run on targeted OS.
#	e.g. build is executed inside Docker container when building Docker image
copy-resources: $(RES_LIST)

# clean:
# 	Undo previous "build".  clean $(DESTDIR) and build cache
# 	This target should be run on targeted OS.
clean:
	$(GO) clean
	rm -rf $(DESTDIR)/*


## Docker
## Prerequisites for building docker image:
## 		- Working machine should have access to relative private Git repositories. (setup by "init-once")
##		- Working machine's ~/.ssh/id_rsa should be added via "ssh-add" for private GitHub servers
##		- Minimum Docker version on working machine is 18.09

# init-docker:
# 	Initialize for building docker image. Typically run on CI/CD worker machine
init-docker:
	# ssh-add is necessary for build-docker
	$(SSHADD) -K ~/.ssh/id_rsa

# build-docker:
# 	Build docker image. Typically run on CI/CD worker machine
# 	Optional Vars:
#		- VERSION application version also used as Docker's image tag. Default to "latest" if not specified
build-docker: DOCKER_TAG = $(if $(VERSION),$(VERSION),latest)
build-docker: init-docker
	$(DOCKER) build -f "build/package/Dockerfile" --ssh default --progress=plain -t europa:$(DOCKER_TAG) .

## CI/CD

# dist:
#	Make a distribution build with provided PRIVATE_MODS and VERSION,
#	tag the source code that could be used to re-build the distribution,
#	and optionally merge updated go.mod/go.sum back to SRC_BRANCH if provided
# 	Required Vars:
#		- PRIVATE_MODS
# 		- VERSION
# 	Optional Vars:
#		- SRC_BRANCH source branch this distribution originated from.
# 		  If set, post-dist would behave differently
dist: init clean pre-dist test build-docker post-dist

# verify:
#	Test and build application against specified PRIVATE_MODS.
# 	Required Vars:
#		- PRIVATE_MODS
verify: init clean pre-verify test build post-verify

## CI/CD AdHoc Targets
## The following targets are useful for CI/CD scenarios such as nightly build, PR review and stable release.
## For example:
## 1.	Nightly build: use pre-dist and post-dist without specifying SRC_BRANCH.
## 		This will result in a tag off of the current branch.
## 2.	Promoting of certain build from a tag or branch: use pre-dist and post-dist without specifying SRC_BRANCH.
## 		This will result in a tag off of the current branch.
## 3.	Making end-of-cycle release: use pre-dist and post-dist with a SRC_BRANCH.
## 		This will result in a tag off of the current branch. The updated go.mod will also be merged back into the source branch.
## 3.	PR verification: use pre-build. This will not create any tag or commits.
## 		For more details, see the build.md file in the docs directory.

pre:
	$(CLI) git mark create -t tmp/pre-make

post:
	$(CLI) git mark revert -t tmp/pre-make -f

# pre-verify:
#	useful for PR review - get mod file ready but no commit.
# 	Required Vars:
#		- PRIVATE_MODS e.g. make pre-build PRIVATE_MODS=cto-github.cisco.com/NFV-BU/go-lanai@develop
pre-verify: pre update-dependency drop-replace

# post-verify:
#	useful for PR review - revert to initial state
post-verify: post


# pre-dist:
# TODO
#	useful for any distribution build
# 	creates two commits. the first commit can be used to merge back to main branch. the second commit can be used for tagging
#	need to provide temporary branch name, and module to be updated
# e.g. make pre-build module=cto-github.cisco.com/NFV-BU/go-lanai:develop branch-name=tmp
pre-dist: UPDATE_DEPS_MARK = tmp/$(VERSION)/update-deps
pre-dist: DROP_REPLACE_MARK = tmp/$(VERSION)/drop-replace
pre-dist: pre update-dependency drop-replace

# post-dist:
# TODO
#useful for release build - tag the build, and also merge back to main branch with the updated dependencies
#publish tag after merge so both push and push tags is at the very end.
#need to provide tag value, and original branch to merge back to
# e.g. make post-build tag-version=0.0.1 original-branch=develop remove-branch=tmp
post-dist: UPDATE_DEPS_MARK = tmp/$(VERSION)/update-deps
post-dist: DROP_REPLACE_MARK = tmp/$(VERSION)/drop-replace
post-dist: git-publish-tag git-merge-back post


#Used to update the module dependency versions
#Will update go.mod's dependency to given branch's latest commit
#This target requires a command line input to specify from which branch to update the dependency
# The dependency version can either be a branch - useful for PR verification
# Or it can be a version query - useful for builds that are tagged (nightly or release)
# e.g make update-dependency module=cto-github.cisco.com/NFV-BU/go-lanai@develop
update-dependency:
	$(CLI) deps update --modules=$(PRIVATE_MODS) --mark=$(UPDATE_DEPS_MARK)

# e.g. make drop-replace module=cto-github.cisco.com/NFV-BU/go-lanai:develop
# or make drop-replace module=cto-github.cisco.com/NFV-BU/go-lanai
#use this after dependency is updated and replace directive is dropped.
#Because if there is a replace directive but the module that's replaced is not being used,
#go mod tidy will remove the dependency but not the replace directive. That would leave the go.mod in an error state
drop-replace:
	$(CLI) deps drop-replace --modules=$(PRIVATE_MODS) --mark=$(DROP_REPLACE_MARK)

git-publish-tag: GIT_TAG = v$(VERSION)
git-publish-tag:
	$(CLI) git mark retag -t $(DROP_REPLACE_MARK) --retag $(GIT_TAG)
	$(GIT) push origin $(GIT_TAG)

git-merge-back:
ifneq ($(SRC_BRANCH),)
	$(GIT) push . $(UPDATE_DEPS_MARK):$(SRC_BRANCH)
endif

# may be useful to check if current branch is the expected branch
git-verify-current-branch:
	set -e ;\
	br=$$($(GIT) branch --show-current) ;\
	[ $$br = $(current-branch) ] || exit 1