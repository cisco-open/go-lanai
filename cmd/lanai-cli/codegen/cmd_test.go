package codegen

import (
	"context"
	"cto-github.cisco.com/NFV-BU/go-lanai/cmd/lanai-cli/cmdutils"
	"cto-github.cisco.com/NFV-BU/go-lanai/cmd/lanai-cli/codegen/generator"
	"cto-github.cisco.com/NFV-BU/go-lanai/test"
	"embed"
	"fmt"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/google/go-cmp/cmp"
	"github.com/onsi/gomega"
	. "github.com/onsi/gomega"
	"io/fs"
	"os"
	"path"
	"path/filepath"
	"testing"
)

const testDir = "testdata/"

//go:embed all:template/src
var ActualFilesystem embed.FS

const serviceName = "testservice"

type TestPlan struct {
	name       string
	contract   string
	wantErr    bool
	filesystem fs.FS
	outputDir  string
	goldenDir  string
	update     bool
}

func TestGenerateTemplates(t *testing.T) {
	plans := []TestPlan{
		{
			name:       "TestServiceGeneration",
			contract:   path.Join(testDir, "test", "test.yaml"),
			wantErr:    false,
			filesystem: ActualFilesystem,
			outputDir:  path.Join(testDir, "test", "output"),
			goldenDir:  path.Join("testdata", "test", "golden"),
			update:     false,
		},
	}

	subTests := make([]test.Options, len(plans))
	for i := range plans {
		subTests[i] = test.GomegaSubTest(SubTestCodeGenerate(&plans[i]), plans[i].name)
	}

	test.RunTest(context.Background(), t,
		subTests...
	)
}

/*************************
	Sub Tests
 *************************/

func SubTestCodeGenerate(tt *TestPlan) test.GomegaSubTestFunc {
	return func(ctx context.Context, t *testing.T, g *gomega.WithT) {
		err := os.RemoveAll(tt.outputDir)
		g.Expect(err).To(Succeed())
		outputDirAbsolute, err := filepath.Abs(tt.outputDir)
		g.Expect(err).To(Succeed(), "Absolute Path for output dir should be available")

		openAPIData, err := openapi3.NewLoader().LoadFromFile(tt.contract)
		if err != nil {
			t.Fatalf("error parsing OpenAPI file: %v", err)
		}

		data := map[string]interface{}{
			generator.CKProjectName: serviceName,
			generator.CKOpenAPIData: openAPIData,
			generator.CKRepository:  "cto-github.cisco.com/NFV-BU/test-service",
			generator.CKProject: generator.Project{
				Name:        serviceName,
				Module:      "cto-github.cisco.com/NFV-BU/test-service",
				Description: "Service generated by lanai-cli",
				Port:        8989,
				ContextPath: "/test",
			},
		}
		templates, err := generator.LoadTemplates(tt.filesystem, generator.LoaderOptions{})
		if err != nil {
			t.Fatalf("Could not load templates: %v", err)
		}

		cmdutils.GlobalArgs.OutputDir = outputDirAbsolute

		err = generator.GenerateFiles(
			generator.WithData(data),
			generator.WithTemplateFS(tt.filesystem),
			generator.WithOutputFS(tt.filesystem),
			generator.WithTemplate(templates))
		if err != nil {
			t.Fatalf("Could not generate: %v", err)
		}
		defer os.RemoveAll(tt.outputDir)
		var f fs.WalkDirFunc

		if tt.update {
			f = updateGoldenOutputFunc(t, tt)
		} else {
			f = compareToGoldenOutputFunc(t, tt)
		}
		err = fs.WalkDir(os.DirFS(tt.outputDir), ".", f)
		if err != nil {
			t.Fatalf("Could not compare output and golden dirs: %v", err)
		}

		if !tt.update {
			// Check if all dirs in Golden directory were created
			e := fs.WalkDir(os.DirFS(tt.goldenDir), ".",
				func(p string, d fs.DirEntry, err error) error {
					if d.Name() != ".ignore" {
						outputPath := path.Join(tt.outputDir, p)
						if _, err := os.Stat(outputPath); os.IsNotExist(err) {
							return fmt.Errorf("%v expected, but does not exist", outputPath)
						}
					}
					return nil
				})
			g.Expect(e).To(Succeed(), "All directories should be created")
		}
	}
}

/*************************
	Helpers
 *************************/

func updateGoldenOutputFunc(t *testing.T, tt *TestPlan) func(p string, d fs.DirEntry, err error) error {
	return func(p string, d fs.DirEntry, err error) error {
		absGoldenPath, err := filepath.Abs(tt.goldenDir)
		if err != nil {
			t.Fatalf("Absolute Path for golden dir not available")
		}
		outputPath := path.Join(tt.outputDir, p)
		goldenPath := path.Join(tt.goldenDir, p)
		if d.IsDir() {
			if _, err := os.Stat(goldenPath); os.IsNotExist(err) {
				dirToCreate := path.Join(absGoldenPath, p)
				err := os.Mkdir(dirToCreate, 0750)
				if err != nil && !os.IsExist(err) {
					t.Fatalf("Could not create directory:%v", err)
				}
			}
		} else {
			r, err := os.ReadFile(outputPath)
			if err != nil {
				t.Fatalf("Could not open output dir file: %v", err)
			}

			fileToUpdate := path.Join(absGoldenPath, p)
			err = os.WriteFile(fileToUpdate, r, 0666)
			if err != nil {
				t.Fatalf("could not update golden directory: %v", err)
			}
		}
		return nil
	}
}

func compareToGoldenOutputFunc(t *testing.T, tt *TestPlan) func(p string, d fs.DirEntry, err error) error {
	return func(p string, d fs.DirEntry, err error) error {

		outputPath := path.Join(tt.outputDir, p)
		goldenPath := path.Join(tt.goldenDir, p)
		if _, err := os.Stat(goldenPath); os.IsNotExist(err) {
			t.Fatalf("%v does not exist", goldenPath)
		}

		if !d.IsDir() {
			expected := path.Join(tt.goldenDir, p)
			e, err := os.ReadFile(expected)
			if err != nil {
				t.Fatalf("Could not open expected file: %v", err)
			}

			r, err := os.ReadFile(outputPath)
			if err != nil {
				t.Fatalf("Could not open result file: %v", err)
			}

			if diff := cmp.Diff(string(e), string(r)); diff != "" {
				t.Errorf("output does not match golden file %v: %s", expected, diff)
			}
		}
		return nil
	}
}
