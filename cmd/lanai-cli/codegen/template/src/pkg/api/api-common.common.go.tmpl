// Package api Generated by lanai-cli codegen. DO NOT EDIT
// Derived from openapi contract - components
package api
{{ with index . "OpenAPIData" }}
    {{- $c := components .Components }}
    {{ $imports := NewImports }}
    {{- with $c.Imports }}
        {{- range . }}
            {{ $imports = $imports.Add . }}
        {{- end }}
    {{- end }}

    {{ template "imports" $imports }}

    {{ template "registerStructs" args .Components }}
    {{ template "componentSchemaStructs" args .Components.Schemas }}
    {{ template "componentRequestBodiesStructs" args .Components.RequestBodies }}
    {{ template "componentParameterStructs" args .Components.Parameters }}
{{- end }}

{{ define "registerStructs" }}
    {{- $components := index . 0 }}

    {{ template "registerSchemaStructs" args $components.Schemas }}

    {{- $requestBodies := $components.RequestBodies }}
    {{ range $requestName, $requestData := $requestBodies }}
        {{- $structName := toTitle $requestName }}
        {{- registerStruct $structName "pkg/api" -}}
    {{- end }}

    {{- $parameters := $components.Parameters }}
    {{ range $parameterName, $parameterData := $parameters }}
        {{- if $parameterData.Value.Schema.Value.Type.Is "object" }}
        {{- $structName := toTitle $parameterName }}
        {{ registerStruct $structName "pkg/api" -}}
        {{- end }}
    {{- end }}

{{- end }}

{{ define "registerSchemaStructs" }}
    {{- $schemas := index . 0 }}

    {{- $namePrefix := "" }}
    {{- $numArgs := len . }}
    {{- if eq $numArgs 2 }}
     {{- $namePrefix = index . 1 }}
    {{- end }}
    {{- $namePrefix = toTitle $namePrefix }}

    {{- range $schemaName, $schemaData := $schemas }}
        {{- $wasCreated := false }}
        {{- $structName := toTitle $schemaName }}
        {{- $structName = concat $namePrefix $structName }}

        {{- $isObject := $schemaData.Value.Type.Is "object" }}
        {{- if or $isObject $schemaData.Value.AllOf }}
            {{- if not $schemaData.Ref }}
                {{- registerStruct $structName "pkg/api" -}}
                {{ $wasCreated = true }}
            {{- end }}
        {{- end }}
        {{- if $wasCreated }}
            {{ template "registerSchemaStructs" args $schemaData.Value.Properties $structName }}
        {{- end }}
    {{- end }}
{{- end }}

{{ define "componentSchemaStructs" }}
    {{- $schemas := index . 0 }}

    {{- $namePrefix := "" }}
    {{- $numArgs := len . }}
    {{- if eq $numArgs 2 }}
     {{- $namePrefix = index . 1 }}
    {{- end }}
    {{- $namePrefix = toTitle $namePrefix }}

    {{- range $schemaName, $schemaData := $schemas }}
        {{- $wasCreated := false }}
        {{- $structName := toTitle $schemaName }}
        {{- $structName = concat $namePrefix $structName }}

        {{- $schema := schema $structName $schemaData }}

        {{- if or $schema.Data.Value.AllOf $schema.Data.Value.Properties }}
            {{- if not $schema.Data.Ref }}
                {{- $struct := NewStruct $structName "pkg/api" }}
                {{- template "SchemaProperties" args $schema "pkg/api" $struct}}
                {{ template "struct" args $struct }}
                {{- $wasCreated = true }}

                {{- if $schema.HasAdditionalProperties }}
                    {{- template "componentWithAdditionalPropertyMarshallingFunctions" args $schema}}
                {{- end }}
            {{- end }}
        {{- end }}
        {{/* Check if something was actually made before diving deeper into the struct */}}
        {{- if $wasCreated }}
            {{/* Make another struct for each applicable property */}}
            {{- range $_, $schemaRef := $schema.AllSchemas }}
                {{- with $schemaRef.Ref }}
                    {{/* This ref will already have a struct made, don't make another one */}}
                {{- else }}
                    {{- $innerSchema := schema $schema.Name $schemaRef }}
                    {{ template "componentSchemaStructs" args $innerSchema.Data.Value.Properties $innerSchema.Name }}
                {{- end }}
            {{- end }}
        {{- end }}
    {{- end }}
{{- end }}

{{ define "componentRequestBodiesStructs" }}
    {{- $requestBodies := index . 0 }}
    {{ range $requestName, $requestData := $requestBodies }}
        {{ $struct := NewStruct $requestName "pkg/api" }}
        {{- range $requestData.Value.Content }}
            {{- $schema := schema $requestName .Schema }}
            {{- template "SchemaProperties" args $schema "pkg/api" $struct }}
        {{- end }}
        {{ template "struct" args $struct }}
    {{- end }}
{{- end }}

{{ define "componentParameterStructs" }}
    {{- $parameters := index . 0 }}
    {{ range $parameterName, $parameterData := $parameters }}
        {{ $structName := toTitle $parameterName }}
        {{- if $parameterData.Value.Schema.Value.Type.Is "object" }}
            {{ $struct := NewStruct $structName "pkg/api" }}
            {{ template "ParameterProperty" args $parameterData "pkg/api" $struct}}
            {{ template "struct" args $struct }}
        {{- end }}
    {{ end }}
{{- end }}

{{ define "componentWithAdditionalPropertyMarshallingFunctions"}}
    {{ $schema := index . 0 }}
    func (t *{{$schema.Name}}) UnmarshalJSON(data []byte) (err error) {
        type ptrType *{{$schema.Name}}
        if e := json.Unmarshal(data, ptrType(t)); e != nil {
            return e
        }
        if e := json.Unmarshal(data, &t.Values); e != nil {
            return e
        }
        return nil
    }

    func (t {{$schema.Name}}) MarshalJSON() ([]byte, error) {
        type {{$schema.Name}}_ {{$schema.Name}}
        bytes, err := json.Marshal({{$schema.Name}}_(t))
        if err != nil {
            return nil, err
        }
        if t.Values == nil || len(t.Values) == 0 {
            return bytes, nil
        }
        extra, err := json.Marshal(t.Values)
        if err != nil {
            return nil, err
        }

        if string(bytes) == "{}"  {
            return extra, nil
        }
        bytes[len(bytes)-1] = ','
        return append(bytes, extra[1:]...), nil
    }
{{- end }}