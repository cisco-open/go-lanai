// Package api Generated by lanai_cli codegen. DO NOT EDIT
// Derived from openapi contract - components
package api
{{ with index . "OpenAPIData" }}
    {{ template "externalCommonImports" args .Components }}
    {{ template "registerStructs" args .Components }}
    {{ template "componentSchemaStructs" args .Components.Schemas }}
    {{ template "componentRequestBodiesStructs" args .Components.RequestBodies }}
    {{ template "componentParameterStructs" args .Components.Parameters }}
{{- end }}

{{ define "externalCommonImports" }}
    {{- $components := index . 0 }}
    {{- $c := components $components }}
    {{- with $c.Imports }}
    import (
        {{ range . }}
        "{{.}}"
        {{- end }}
    )
    {{- end }}
{{- end }}

{{ define "registerStructs" }}
    {{- $components := index . 0 }}

    {{ template "registerSchemaStructs" args $components.Schemas }}

    {{- $requestBodies := $components.RequestBodies }}
    {{ range $requestName, $requestData := $requestBodies }}
        {{- $structName := toTitle $requestName }}
        {{- registerStruct $structName "pkg/api" -}}
    {{- end }}

    {{- $parameters := $components.Parameters }}
    {{ range $parameterName, $parameterData := $parameters }}
        {{- if eq $parameterData.Value.Schema.Value.Type "object" }}
        {{- $structName := toTitle $parameterName }}
        {{ registerStruct $structName "pkg/api" -}}
        {{- end }}
    {{- end }}

{{- end }}

{{ define "registerSchemaStructs" }}
    {{- $schemas := index . 0 }}

    {{- $namePrefix := "" }}
    {{- $numArgs := len . }}
    {{- if eq $numArgs 2 }}
     {{- $namePrefix = index . 1 }}
    {{- end }}
    {{- $namePrefix = toTitle $namePrefix }}

    {{- range $schemaName, $schemaData := $schemas }}
        {{- $wasCreated := false }}
        {{- $structName := toTitle $schemaName }}
        {{- $structName = concat $namePrefix $structName }}

        {{- $isObject := eq $schemaData.Value.Type "object" }}
        {{- if or $isObject $schemaData.Value.AllOf }}
            {{- if not $schemaData.Ref }}
                {{- registerStruct $structName "pkg/api" -}}
                {{ $wasCreated = true }}
            {{- end }}
        {{- end }}
        {{- if $wasCreated }}
            {{ template "registerSchemaStructs" args $schemaData.Value.Properties $structName }}
        {{- end }}
    {{- end }}
{{- end }}

{{ define "componentSchemaStructs" }}
    {{- $schemas := index . 0 }}

    {{- $namePrefix := "" }}
    {{- $numArgs := len . }}
    {{- if eq $numArgs 2 }}
     {{- $namePrefix = index . 1 }}
    {{- end }}
    {{- $namePrefix = toTitle $namePrefix }}

    {{- range $schemaName, $schemaData := $schemas }}
        {{- $wasCreated := false }}
        {{- $structName := toTitle $schemaName }}
        {{- $structName = concat $namePrefix $structName }}

        {{- $schema := schema $structName $schemaData }}

        {{- if or $schema.Data.Value.AllOf $schema.Data.Value.Properties }}
            {{- if not $schema.Data.Ref }}
                type {{ $schema.Name }} struct {
                    {{- template "SchemaProperties" args $schema "pkg/api" }}
                }
                {{- $wasCreated = true }}

                {{- if $schema.HasAdditionalProperties }}
                    {{- template "componentWithAdditionalPropertyMarshallingFunctions" args $schema}}
                {{- end }}
            {{- end }}
        {{- end }}
        {{/* Check if something was actually made before diving deeper into the struct */}}
        {{- if $wasCreated }}
            {{/* Make another struct for each applicable property */}}
            {{- range $_, $schemaRef := $schema.AllSchemaRefs }}
                {{- with $schemaRef.Ref }}
                    {{/* This ref will already have a struct made, don't make another one */}}
                {{- else }}
                    {{- $innerSchema := schema $schema.Name $schemaRef }}
                    {{ template "componentSchemaStructs" args $innerSchema.Data.Value.Properties $innerSchema.Name }}
                {{- end }}
            {{- end }}
        {{- end }}
    {{- end }}
{{- end }}

{{ define "componentRequestBodiesStructs" }}
    {{- $requestBodies := index . 0 }}
    {{ range $requestName, $requestData := $requestBodies }}
        type {{ toTitle $requestName }} struct {
                {{- range $requestData.Value.Content }}
                    {{- $schema := schema $requestName .Schema }}
                    {{- template "SchemaProperties" args $schema "pkg/api" }}
                {{- end }}
        }
    {{- end }}
{{- end }}

{{ define "componentParameterStructs" }}
    {{- $parameters := index . 0 }}
    {{ range $parameterName, $parameterData := $parameters }}
        {{- if eq $parameterData.Value.Schema.Value.Type "object" }}
        type {{ toTitle $parameterName }} struct {
            {{ template "ParameterProperty" args $parameterData "pkg/api" }}
        }
        {{- end }}
    {{ end }}
{{- end }}

{{ define "componentWithAdditionalPropertyMarshallingFunctions"}}
    {{ $schema := index . 0 }}
    func (t *{{$schema.Name}}) UnmarshalJSON(data []byte) (err error) {
        type ptrType *{{$schema.Name}}
        if e := json.Unmarshal(data, ptrType(t)); e != nil {
            return e
        }
        if e := json.Unmarshal(data, &t.Values); e != nil {
            return e
        }
        return nil
    }

    func (t {{$schema.Name}}) MarshalJSON() ([]byte, error) {
        result := make(map[string]interface{})
        for i, j := range t.Values {
            result[i] = j
        }
        {{- range $x, $y := $schema.AllSchemaRefs }}
            {{- $inner := schema "" $y }}
            {{- range $i, $j := $inner.AllProperties }}
                result["{{$i}}"] = t.{{toTitle $i}}
            {{- end }}
        {{- end }}
        return json.Marshal(result)
    }
{{- end }}